---
source: tests/generation.rs
expression: generated
---
// Equivalent windows_sys imports
// use windows_sys::Win32::{
//     Foundation::{GetLastError, BOOL, ERROR_TIMEOUT},
//     System::{
//         LibraryLoader::{GetModuleHandleA, GetProcAddress},
//         WindowsProgramming::INFINITE,
//     },
// };

#[minwin]
mod example {
    pub const INFINITE: u32 = 4294967295;
    pub type HMODULE = isize;
    pub type FARPROC = Option<unsafe extern "system" fn() -> isize>;
    pub type WakeByAddressSingle = unsafe extern "system" fn(Address: *const std::ffi::c_void);
    #[link(name = "kernel32")]
    extern "system" {
        pub fn GetModuleHandleA(lpModuleName: *const u8) -> HMODULE;
        pub fn GetProcAddress(hModule: HMODULE, lpProcName: *const u8) -> FARPROC;
    }
}

use example::*;

struct Wait {
    wait: WaitAddress,
    wake: WakeByAddressSingle,
}

fn boop() -> Option<Wait> {
    let synch_dll = unsafe { GetModuleHandleA(b"api-ms-win-core-synch-l1-2-0.dll\0".as_ptr()) };
    if synch_dll == 0 {
        panic!("oh no");
    }

    let wait = unsafe { GetProcAddress(synch_dll, b"WaitOnAddress\0".as_ptr())? };
    let wake = unsafe { GetProcAddress(synch_dll, b"WakeByAddressSingle\0".as_ptr())? };

    let wait: WaitAddress = unsafe { std::mem::transmute(wait) };
    let wake: WakeByAddressSingle = unsafe { std::mem::transmute(wake) };

    Some(Wait { wait, wake })
}

